; SENDING/RECEIVING DATA TO ARDUINO
; INTERCEPT DISK CALL $4010
CPU Z80
FNAME "MSXDISK.BIN"

RDSLREG: EQU $F365
VOICEAQ: EQU $F975
LOADADR: EQU $D000

;MSX .BIN HEADER
DB $FE
DW START, START+(END-MAIN)+(ENDLOADER-START), START

ORG LOADADR
;PLACE CODE IN VOICE A-C AREA
;CHANGE HOOK AT $F365 TO GO THROUGH OUR CODE
START:
DI
LD HL,ENDLOADER
LD DE,VOICEAQ
LD BC,END-MAIN
LDIR
LD HL,HOOK
LD (RDSLREG+1),HL
LD A,$C3
LD (RDSLREG),A
EI
RET
ENDLOADER:

ORG VOICEAQ
MAIN:
; HL TRANSFER ADDRESS DE SECTOR NR B NR OF SECTORS
; A=$52->READ, A=$57->WRITE
; COMMAND STRUCTURE 4 BYTES: 
; 0:'R'/'W' 1: DISK_NR 2: SECTOR_NR LOW BYTE 3: SECTOR_NR HIGH BYTE
RWSECTORS:
LD (COMMANDBUF),A		;STORE COMMAND
XOR A
LD (COMMANDBUF+1),A
LD (COMMANDBUF+2),DE
.SECTORLOOP:
CALL STARTCMD			;SEND START PULS, CARRY SET ON ERROR
RET C
PUSH HL					;SAVE HL, SEND COMMAND TO ARDUINO
LD HL,COMMANDBUF
LD BC,$0004
CALL SENDBYTES
LD D,$00				;WAIT FOR ACK, CARRY SET ON ERROR/TIMEOUT
CALL WAITFORARDUINO
POP HL
RET C
LD A,(COMMANDBUF)
CP $52				; 'R'->READ OTHERWISE WRITE
JR Z,.RECEIVE
LD BC,$0200
CALL SENDBYTES
JR .CONTINUE
.RECEIVE:
CALL RECEIVEBYTES
.CONTINUE:
EX DE,HL			;NEXT SECTOR	
LD HL,(COMMANDBUF+2)
INC HL
LD (COMMANDBUF+2),HL
EX DE,HL
LD A,(SECTORCNT)
DEC A
LD (SECTORCNT),A
JR NZ,.SECTORLOOP
RET

; WAIT FOR 'ARDUINO READY SIGNAL'
; SEND TRIGGER PULS TO ARDUINO AND SELECT JOYSTICK PORT 2
; CHANGES AF,D,BC PORT $A0
STARTCMD:
LD D,$0F
CALL WAITFORARDUINO	;IS ARDUINO READY?
RET C				;TIMEOUT ERROR
LD A,$0F
OUT ($A0),A
IN A,($A2)		
; TRIGGER ARDUINO
SET 6,A				;SELECT JOYSTICK PORT2
AND 11010011B 		;211	;PIN 6-7-8 OUTPUT LOW
OUT ($A1),A
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A				;PIN8 LOW 
OR $0C				;PIN 6-7 HIGH
OUT ($A1),A			
RET

;TODO CHANGE REGISTERS IN CODE DUE TO CHANGES
;WAIT FOR ARDUINO READY OR ACK COMMAND
; D=0->ACK , D=$0F->READY SET CARRY ON TIMEOUT
;CHANGES AF, BC, PORT $A0
WAITFORARDUINO:
LD BC,$1000
LD A,$0E
OUT ($A0),A 
.WAITLOOP:
IN A,($A2)		;READ PIN 1-4
AND $0F
CP D
RET Z
DEC BC
LD A,B
OR C
JR NZ,.WAITLOOP
SCF
RET

RECEIVEBYTES:
; RECEIVE 512 BYTES; 1024 NIBBLES [HL] IS DATA BUFFER
; CHANGES AF,HL,BC,DE, PORT $A0
LD BC,$0200
LD A,$0F
OUT ($A0),A
IN A,($A2)		
LD E,A				;EXPERIMENT STORE VALUE IN E
.RECEIVELOOP:
SET 5,A				;SET PIN8 HIGH
OUT ($A1),A
LD A,$0E
OUT ($A0),A
IN A,($A2)		
AND 00001111B		;NIBBLE (LOW)
LD D,A 				;STORE IN D
LD A,$0F
OUT ($A0),A
LD A,E
RES 5,A				;PIN8 LOW
OUT ($A1),A
SET 5,A
OUT ($A1),A			;PIN8 HIGH
LD A,$0E
OUT ($A0),A
IN A,($A2)		
AND 00001111B		;NIBBLE (HIGH)
RLCA
RLCA
RLCA
RLCA
OR D 				;COMBINE 2 NIBBLES
LD (HL),A			;STORE
LD A,$0F
OUT ($A0),A
LD A,E
RES 5,A				;PIN8 LOW
OUT ($A1),A
INC HL
DEC BC 
LD A,B
OR C
LD A,E
JP NZ,.RECEIVELOOP
RET

; SEND DATA [HL] LENGTH BC; LSB FIRST
; CHANGES AF,HL,DE,BC, PORT $A0
SENDBYTES:
LD A,$0F
OUT ($A0),A
.BYTELOOP:
LD A,(HL) 
LD D,A
; FIRST 2 BITS 
AND 00000011B
RLCA
RLCA
LD E,A
IN A,($A2)
AND 11110011B
OR E
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A 			;PIN8 LOW
OUT ($A1),A
; SECOND 2 BITS
LD A,D
AND 00001100B
LD E,A
IN A,($A2)
AND 11110011B
OR E
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A				;PIN8 LOW 	
OUT ($A1),A
; THIRD SET OF 2 BITS
LD A,D
RRCA
RRCA
LD D,A
AND 00001100B
LD E,A
IN A,($A2)
AND 11110011B
OR E
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A				;PIN8 LOW
OUT ($A1),A
; LAST SET OF 2 BITS
LD A,D
RRCA
RRCA
AND 00001100B
LD E,A
IN A,($A2)
AND 11110011B
OR E
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A 			;PIN8 LOW
OUT ($A1),A
; SET FOR NEXT BYTE
INC HL
DEC BC
LD A,B
OR C
JP NZ,.BYTELOOP
IN A,($A2)			; SET PIN 6-7 HIGH
OR $0C
OUT ($A1),A
RET

;CHECK IF THE CALL ORIGINATES FROM DISKIO $4010
HOOK:
PUSH AF
PUSH HL
PUSH DE
PUSH BC
LD HL,$0008			;COMPENSATE FOR PUSH 4*2=8
ADD HL,SP
LD DE,STACKTRACE
LD BC,END-STACKTRACE
.LOOP:
LD A,(DE)
CPI
INC DE
JP NZ,.NODISKCALL		;NO MATCH, READ $A8 REGISTER AND RETURN
JP PE,.LOOP
;YES, WE NEED TO READ/WRITE TO DISK
DI
POP BC
LD A,B				;NR OF SECTORS
LD (SECTORBUF),A
LD (SECTORCNT),A
POP DE
POP HL
POP AF
;LD (COMMANDBUF+1),A		;OPTIONAL:STORE DRIVE NR

;WRITE DISK
LD A,$57		;'W' FOR WRITE
JR C,.STARTIO	;CARRY MEANS WRITE,OTHERWISE READ
;READ DISK
LD A,$52		;'R' FOR READ
.STARTIO:
CALL RWSECTORS	;IF ERROR, CARRY IS SET ON RETURN
PUSH AF
LD A,$0F		;SELECT JOYSTICK PORT 1
OUT ($A0),A
IN A,($A2)
RES 6,A				
OUT ($A1),A
; RETURN TO ORIGINAL CALLER OF $4010
EX DE,HL		;SAVE VALUE OF HL
LD HL,$0014		;CORRECT FOR AF ON STACK: 12+2
ADD HL,SP		;AFFECTS CARRY
POP AF
LD SP,HL
EX DE,HL
; CARRY MEANS ERROR
LD A,$02			;DISK NOT READY
LD B,$00			;NO VALID SECTORS READ
JR C,.EXIT
LD A,(SECTORBUF)	;NR OF SECTORS READ
LD B,A
OR A				;RESET CARRY FLAG
.EXIT:
EI					;ENABLE INT
RET
.NODISKCALL:		;NO, RETURN TO THE NORMAL PROGRAM
POP BC
POP DE
POP HL
POP AF
IN A,($A8)
RET

SECTORCNT:		; STORES SECTOR COUNTER DURING TRANSFER
DB $00
SECTORBUF:
DB $00			; STORES NR OF SECORS WRITTEN/READ (COPY OF B)
COMMANDBUF:		; STORES COMMANDS FOR THE ARDUINO
DB $00,$00,$00,$00
STACKTRACE:		; SPECIFIC STACKTRACE FOR NMS8245 DISKROM
DB $EA,$5F,$D0,$5F,$C5,$5F,$DC,$76
END:
