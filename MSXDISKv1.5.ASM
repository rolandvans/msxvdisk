; SENDING/RECEIVING DATA TO ARDUINO
; INTERCEPT DISK CALL $4010
CPU Z80
FNAME "MSXDISK.BIN"

RDSLREG:  EQU $F365 ;DISK HOOK TO EXPLOIT
VOICEAQ:  EQU $F975 ;BUFFER TO OCCUPY IN SYSTEM AREA: DO NOT USE PLAY... 
LOADADR:  EQU $D000 ;ADDRESS TO LOAD THE CODE AND SET-UP DRIVER
RAMAD1:   EQU $F342	;RAM IN PAGE 1
MASTER:   EQU $F348	;MAIN DISKROM SLOT ADDRESS

WAITTIME: EQU $1000	;TIMEOUT VALUE FOR ARDUINO TO RESPOND ~X ms
CODELEN:  EQU END-MAIN

;MSX .BIN HEADER
DB $FE
DW START, START+(END-MAIN)+(ENDLOADER-START)-1, START

ORG LOADADR
START:
;PLACE CODE IN VOICE A-C AREA
DI
LD HL,ENDLOADER
LD DE,VOICEAQ
LD BC,END-MAIN
LDIR
;CHANGE HOOK AT $F365 TO GO THROUGH OUR CODE
LD HL,HOOK
LD (RDSLREG+1),HL
LD A,$C3
LD (RDSLREG),A
EI
RET
ENDLOADER:

ORG VOICEAQ
MAIN:
; HL TRANSFER ADDRESS DE START SECTOR NR B NR OF SECTORS
; A=$52->READ, A=$57->WRITE
; COMMAND STRUCTURE 4 BYTES: 
; 0:'R'/'W' 1: DISK_NR 2: SECTOR_NR LOW BYTE 3: SECTOR_NR HIGH BYTE
RWSECTORS:
LD (COMMANDBUF),A		;STORE COMMAND
LD (COMMANDBUF+2),DE	;STORE START SECTOR
	.SECTORLOOP:
	CALL STARTCMD			;SEND START PULS, CARRY SET ON ERROR
	RET C
	PUSH HL					;SAVE HL, SEND COMMAND TO ARDUINO
	LD HL,COMMANDBUF
	LD B,$04
	CALL SENDBYTES
	LD D,$00				;WAIT FOR ACK, CARRY SET ON ERROR/TIMEOUT
	CALL WAITFORARDUINO
	POP HL
	RET C
	LD A,(COMMANDBUF)
	CP $52				; 'R'->READ OTHERWISE WRITE
	JR Z,.RECEIVE
	LD B,$00			;SEND SECTOR: FIRST 256 BYTES 
	CALL SENDBYTES
	LD B,$00			;SEND SECOND 256 BYTES
	CALL SENDBYTES
	JR .CONTINUE
	.RECEIVE:
	CALL RECEIVEBYTES	;RECIEVE 512 BYTES (1 SECTOR)
	.CONTINUE:
	EX DE,HL			;NEXT SECTOR	
	LD HL,(COMMANDBUF+2)
	INC HL
	LD (COMMANDBUF+2),HL
	EX DE,HL
	LD A,(SECTORCNT)
	DEC A
	LD (SECTORCNT),A
	JR NZ,.SECTORLOOP
RET

; WAIT FOR 'ARDUINO READY SIGNAL'
; SEND TRIGGER PULS TO ARDUINO AND SELECT JOYSTICK PORT 2
; CHANGES AF,D,BC PORT $A0
STARTCMD:
LD D,$0F
CALL WAITFORARDUINO		;IS ARDUINO READY?
RET C					;TIMEOUT ERROR
LD A,$0F
OUT ($A0),A
IN A,($A2)		
; TRIGGER ARDUINO
SET 6,A				;SELECT JOYSTICK PORT2
AND 11010011B 		;211	;PIN 6-7-8 OUTPUT LOW
OUT ($A1),A
SET 5,A				;PIN8 HIGH
OUT ($A1),A
RES 5,A				;PIN8 LOW 
OR $0C				;PIN 6-7 HIGH
OUT ($A1),A			
RET

;WAIT FOR ARDUINO READY OR ACK COMMAND
; D=0->ACK , D=$0F->READY SET CARRY ON TIMEOUT
;CHANGES AF, BC, PORT $A0
WAITFORARDUINO:
LD BC,WAITTIME
LD A,$0E
OUT ($A0),A 
	.WAITLOOP:
	IN A,($A2)		;READ PIN 1-4
	AND $0F
	CP D
	RET Z
	DEC BC
	LD A,B
	OR C
	JR NZ,.WAITLOOP
SCF				;TIME OUT, RETURN WITH CF SET
RET

RECEIVEBYTES:
; RECEIVE 512 BYTES; 1024 NIBBLES [HL] IS DATA BUFFER
; CHANGES AF,HL,BC,DE, PORT $A0
CALL .READ256BYTES
.READ256BYTES:
LD BC,$000F
LD D,11011111B
LD A,C
OUT ($A0),A
IN A,($A2)		
SET 5,A
LD E,A				;STORE VALUE FROM PSG #15 IN E
	.RECEIVELOOP:
	LD A,E				;STORE VALUE FROM PSG #15 IN E
	OUT ($A1),A			;SET PIN8 HIGH
	LD A,$0E
	OUT ($A0),A
	IN A,($A2)		
	RRD					;STORE LOW NYBBLE
	LD A,C
	OUT ($A0),A
	LD A,E
	AND D				;PIN8 LOW
	OUT ($A1),A
	LD A,E
	OUT ($A1),A			;PIN8 HIGH
	LD A,$0E
	OUT ($A0),A
	IN A,($A2)		
	RRD					;STORE HIGH NYBBLE
	LD A,C
	OUT ($A0),A
	LD A,E
	AND D				;PIN8 LOW
	OUT ($A1),A
	INC HL
	DJNZ .RECEIVELOOP
RET

;SEND MAX 256 BYTES (CALL TWICE FOR 512 BYTES)
; SEND DATA [HL] LENGTH BC; LSB FIRST
; CHANGES AF,HL,DE,BC, PORT $A0
SENDBYTES:
LD A,$0F		;SELECT PSG REG $0F
OUT ($A0),A
IN A,($A2)		;STORE CURRENT VALUE
AND 11110011B	;PIN 6-7 LOW
SET 5,A			;PIN8 HIGH
LD E,A
	.BYTELOOP:
	LD A,(HL)
	RLCA			;PRE ROTATE TO ALIGN WITH PSG#15
	RLCA
	LD D,A			;STORE BYTE VALUE [HL] IN D
	LD C,B			;STORE LOOP BYTELOOP VALUE IN C
	LD B,$04		;INNER LOOP: SEND 2 BITS AT A TIME
		.LOOP:
		AND $0C
		OR E
		OUT ($A1),A		;SEND 2 BITS AND PIN8 HIGH
		AND 11011111B
		OUT ($A1),A		;PIN 8 LOW
		LD A,D
		RRCA
		RRCA
		LD D,A
		DJNZ .LOOP
	LD B,C
	; SET FOR NEXT BYTE
	INC HL
	DJNZ .BYTELOOP
LD A,E
OR $0C	;PIN 6-7 HIGH
RES 5,A	;PIN 8 LOW
OUT ($A1),A
RET

;CHECK IF THE CALL ORIGINATES FROM DISKIO $4010
HOOK:
PUSH AF
PUSH HL
PUSH DE
PUSH BC
LD HL,$0008			;COMPENSATE FOR PUSH 4*2=8
ADD HL,SP
LD DE,STACKTRACE
LD BC,END-STACKTRACE
	.LOOP:
	LD A,(DE)
	CPI
	INC DE
	JP NZ,.NODISKCALL		;NO MATCH, READ $A8 REGISTER AND RETURN
	JP PE,.LOOP
;YES, WE NEED TO READ/WRITE TO DISK
DI
POP BC
LD A,B				;NR OF SECTORS
LD (SECTORBUF),A
LD (SECTORCNT),A
; CHANGE TO RAM IN SLOT1
LD A,(RAMAD1)
CALL SETPAGE1
POP DE
POP HL
POP AF
LD (COMMANDBUF+1),A		;STORE DRIVE NR
;WRITE DISK
LD A,$57		;'W' FOR WRITE
JR C,.STARTIO	;CARRY MEANS WRITE,OTHERWISE READ
;READ DISK
LD A,$52		;'R' FOR READ
.STARTIO:
CALL RWSECTORS	;IF ERROR, CARRY IS SET ON RETURN
PUSH AF			;SAVE FLAG
; CHANGE TO DISKROM IN SLOT1
LD A,(MASTER)
CALL SETPAGE1
LD A,$0F		;SELECT JOYSTICK PORT 1
OUT ($A0),A
IN A,($A2)
RES 6,A				
OUT ($A1),A
; RETURN TO ORIGINAL CALLER OF $4010
EX DE,HL		;SAVE VALUE OF HL
LD HL,$0014		;CORRECT FOR AF ON STACK: 12+2
ADD HL,SP		;AFFECTS CARRY
POP AF
LD SP,HL
EX DE,HL
; CARRY MEANS ERROR
LD A,$02			;DISK NOT READY
LD B,$00			;NO VALID SECTORS READ
JR C,.EXIT
LD A,(SECTORBUF)	;NR OF SECTORS READ
LD B,A
OR A				;RESET CARRY FLAG
.EXIT:
EI					;ENABLE INT
RET
.NODISKCALL:		;NO, RETURN TO THE NORMAL PROGRAM
POP BC
POP DE
POP HL
POP AF
IN A,($A8)
RET

SETPAGE1:
;SWAP RAM<->DISKROM, A HOLDS SLOT
;MODIFIES A,BC PAGE1 AND ASSUMES RAM IS IN SAME SLOT(!!)
LD B,A
AND $03
RLCA
RLCA
LD C,A
IN A,($A8)
AND 11110011B
OR C
OUT ($A8),A
LD A,B
AND 00001100B
LD C,A
LD A,($FFFF)
CPL
AND 11110011B
OR C
LD ($FFFF),A
RET

SECTORCNT:		; STORES SECTOR COUNTER DURING TRANSFER
DB $00
SECTORBUF:
DB $00			; STORES NR OF SECTORS WRITTEN/READ (COPY OF B)
COMMANDBUF:		; STORES COMMANDS FOR THE ARDUINO
DB $00,$00,$00,$00	; 'R'/'W'; DISKNR; SECTORNR LL; SECTORNR HH
STACKTRACE:		; SPECIFIC STACKTRACE FOR NMS8245 DISKROM
DW $5FEA,$5FD0,$5FC5,$76DC
END:
